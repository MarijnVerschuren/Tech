@startuml
'skinparam linetype ortho

' guard (conditional statement) "[condition]"
'	A --timeout[x=3]--> B (only happens when condition is met)
' action "/action"
'	B --timeout[x=2]/led_on()--> C (only happens once)

' entry / exit
'	| state 	|
'	|-----------|
'	| entry:	|
'	|  action_a	|  reset timer here
'	| do:		|
'	|  action_b |
'	| exit:		|
'	|  action_c	|

' look at the microwave project

state standby
standby : entry:
standby : display.off()
standby : cancel_all()
standby : exit:
standby : load_default_program()
standby : display.on()

state program_select
program_select : entry:
program_select : start_timeout_timer(5 MIN)
program_select : display.set_current_task(NO_INDICATOR)
program_select : display.set_menu_number(program)
program_select : display.set_time(program.time + get_time())  // this is split like so: (H, M)
program_select : // display updates remaining time automatically every minute
program_select : exit:
program_select : stop_timeout_timer()
state oven_check <<choice>>

[*]						->			standby
standby					->			program_select			: MENU_BUTTON_PRESSED
selecting				-->			standby					: TIMER_TIMEOUT \n MENU_BUTTON_LONG_PRESSED
processing				-->			standby					: MENU_BUTTON_LONG_PRESSED

program_select		->			program_select			: MENU_BUTTON_PRESSED/load_next_program()
program_select		->			program_select			: TIMER_UP_BUTTON_PRESSED \n /increment_time() // by 10
program_select		->			program_select			: TIMER_DOWN_BUTTON_PRESSED \n /decrement_time() // by 10
program_select		-->			oven_check				: START_BUTTON_PRESSED
oven_check			-->			program_select			: [oven.GetTemperature() > max_temp] \n /blink_led(10)
oven_check			-->			processing


state processing {
	state kneading
	state rising
    rising : entry:
    rising : display.set_current_task(RISING)
    rising : // oven call starts its own timer
    rising : oven.StartRise(rise_time)
    state rise_choice <<choice>>
	state baking

	state "resting" as wait_resting
	wait_resting : entry:
	wait_resting : display.set_current_task(WAITING)
	wait_resting : // set timer at time set by in/decrease_timer
	wait_resting : set_timer(get_time())

	state process_choice <<choice>>
	state yeast_choice <<choice>>
	state extras_choice <<choice>>

	[*]					-->			process_choice
	process_choice		->			wait_resting
	process_choice		-->			baking					: [program = "bake"]
	wait_resting		-->			yeast_choice			: TIMER_TIMEOUT
	yeast_choice		-->			extras_choice			: [program.addYeast] \n /yeast.Drop(yeast_time)
	yeast_choice		-->			extras_choice
	extras_choice		-->			kneading				: [program.addExtras] \n /extras.Drop(extras_time)
	extras_choice		-->			kneading
	rising				-->			rise_choice				: TIMER_TIMEOUT
	rise_choice			-->			done					: [program == "dough"]
	rise_choice			-->			baking
	baking				->			done					: TIMER_TIMEOUT
	done				-->			standby					: TIMER_TIMEOUT
}

baking : entry:
baking : display.set_current_task(BAKING)
baking : // add time set by in/decrease_timer to bake time if program = "bake"
baking : // ()oven call starts its own timer)
baking : oven.StartBake(program.bake [+ get_time()])

state kneading {
	state turn_left
	turn_left : entry:
	turn_left : set_timer(1 MIN)
	turn_left : knead_cycles++
	turn_left : motor.turn_left()
	turn_left : exit:
	turn_left : motor.stop()
	state turn_right
	turn_right : entry:
	turn_right : set_timer(1 MIN)
	turn_right : knead_cycles++
	turn_right : motor.turn_right()
	turn_right : exit:
	turn_right : motor.stop()

	[*]					-->			turn_left
	turn_left			->			turn_right				: TIMER_TIMEOUT
	turn_right			->			turn_left				: TIMER_TIMEOUT
	kneading			-->			rising					: TIMER_TIMEOUT \n [knead_cycles = program.kneading]
}
kneading : entry:
kneading : display.set_current_task(KNEADING)

state done
done : entry:
done : display.set_current_task(DONE)
done : set_timer(5 MIN)

@enduml